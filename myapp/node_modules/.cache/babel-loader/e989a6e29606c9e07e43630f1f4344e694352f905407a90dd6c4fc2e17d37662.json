{"ast":null,"code":"import { useState as e, useEffect as r } from \"react\";\nfor (var n = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", t = new Map(), o = 0; o < n.length; o++) {\n  var a = o.toString(2);\n  a = \"0\".repeat(6 - a.length) + a, t.set(n.charCodeAt(o), a);\n}\nfunction l(e) {\n  try {\n    if (\"string\" != typeof e || 3 !== e.split(\".\").length) return null;\n    var r = function (e) {\n        for (var r = \"\", n = 0; n < e.length; n++) r += t.get(e.charCodeAt(n));\n        r = r.slice(0, r.length - r.length % 8);\n        for (var o = [], a = 0; a < r.length / 8; a++) o.push(r.slice(8 * a, 8 * a + 8));\n        return o;\n      }(e.split(\".\")[1].replaceAll(\"=\", \"\").replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\")).map(function (e) {\n        return parseInt(e, 2);\n      }),\n      n = decodeURIComponent(function (e) {\n        for (var r, n = \"\", t = e.length, o = 0; o < t; o++) r = e[o], n += String.fromCodePoint(r > 251 && r < 254 && o + 5 < t ? 1073741824 * (r - 252) + (e[++o] - 128 << 24) + (e[++o] - 128 << 18) + (e[++o] - 128 << 12) + (e[++o] - 128 << 6) + e[++o] - 128 : r > 247 && r < 252 && o + 4 < t ? (r - 248 << 24) + (e[++o] - 128 << 18) + (e[++o] - 128 << 12) + (e[++o] - 128 << 6) + e[++o] - 128 : r > 239 && r < 248 && o + 3 < t ? (r - 240 << 18) + (e[++o] - 128 << 12) + (e[++o] - 128 << 6) + e[++o] - 128 : r > 223 && r < 240 && o + 2 < t ? (r - 224 << 12) + (e[++o] - 128 << 6) + e[++o] - 128 : r > 191 && r < 224 && o + 1 < t ? (r - 192 << 6) + e[++o] - 128 : r);\n        return n;\n      }(r));\n    return JSON.parse(n);\n  } catch (e) {\n    return console.error(\"There was an error decoding token: \", e), null;\n  }\n}\nfunction i(e) {\n  var r = l(e),\n    n = !0;\n  if (r && r.exp) {\n    var t = new Date(0);\n    t.setUTCSeconds(r.exp), n = t.valueOf() < new Date().valueOf();\n  }\n  return n;\n}\nfunction c(n) {\n  var t = e(!1),\n    o = t[0],\n    a = t[1],\n    c = e(null),\n    u = c[0],\n    f = c[1];\n  r(function () {\n    p(n);\n  }, [n]);\n  var p = function (e) {\n    f(l(e)), a(i(e));\n  };\n  return {\n    isExpired: o,\n    decodedToken: u,\n    reEvaluateToken: p\n  };\n}\nexport { l as decodeToken, i as isExpired, c as useJwt };","map":{"version":3,"names":["n","t","Map","o","length","a","toString","repeat","set","charCodeAt","l","e","split","r","get","slice","push","replaceAll","map","parseInt","decodeURIComponent","String","fromCodePoint","JSON","parse","console","error","i","exp","Date","setUTCSeconds","valueOf","c","u","f","p","isExpired","decodedToken","reEvaluateToken","decodeToken","useJwt"],"sources":["D:\\New folder (2)\\Projects\\AnimeSpectra\\myapp\\node_modules\\react-jwt\\src\\helpers\\base64.ts","D:\\New folder (2)\\Projects\\AnimeSpectra\\myapp\\node_modules\\react-jwt\\src\\jwt\\index.ts","D:\\New folder (2)\\Projects\\AnimeSpectra\\myapp\\node_modules\\react-jwt\\src\\hooks\\index.tsx"],"sourcesContent":["const map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst reverseMap = new Map();\n\nfor (let i = 0; i < map.length; i++) {\n  let bits: string = i.toString(2);\n  const padding: number = 6 - bits.length;\n  bits = \"0\".repeat(padding) + bits;\n\n  reverseMap.set(map.charCodeAt(i), bits);\n}\n\n/**\n * Convert base64 string to an array of bytes\n * @param base64Str - Base64 string\n * @returns Array of 1-byte elements\n */\nfunction toByteArray(base64Str: string): string[] {\n  let bits: string = \"\";\n\n  // convert base64 string to bits\n  for (let i = 0; i < base64Str.length; i++) {\n    bits += reverseMap.get(base64Str.charCodeAt(i));\n  }\n\n  // Remove padding (\"=\" characters)\n  bits = bits.slice(0, bits.length - (bits.length % 8));\n\n  const bytesArray = [];\n\n  // Separate string by 8-bit groups\n  for (let i = 0; i < bits.length / 8; i++) {\n    bytesArray.push(bits.slice(i * 8, i * 8 + 8));\n  }\n\n  return bytesArray;\n}\n\n/**\n * Convert a base64 string to an UTF-8 array\n * @param base64Str - Base64 string\n * @returns UTF-8 array\n */\nexport function base64DecToArray(base64Str: string): number[] {\n  // Replace - _ and remove padding\n  base64Str = base64Str.replaceAll(\"=\", \"\");\n  base64Str = base64Str.replaceAll(\"-\", \"+\");\n  base64Str = base64Str.replaceAll(\"_\", \"/\");\n\n  const charCodes: string[] = toByteArray(base64Str);\n\n  return charCodes.map((code) => parseInt(code, 2));\n}\n\n/**\n * Convert a UTF-8 array to string\n * @param bytes\n * @returns Decoded string\n */\nexport function UTF8ArrToStr(bytes: number[]): string {\n  let decoded: string = \"\"; // Decoded string\n  let nPart: number;\n  const arrayLength: number = bytes.length;\n\n  for (let i = 0; i < arrayLength; i++) {\n    nPart = bytes[i];\n    decoded += String.fromCodePoint(\n      nPart > 251 && nPart < 254 && i + 5 < arrayLength /* six bytes */\n        ? /* (nPart - 252 << 30) may be not so safe in ECMAScript! So... */\n          (nPart - 252) * 1073741824 +\n            ((bytes[++i] - 128) << 24) +\n            ((bytes[++i] - 128) << 18) +\n            ((bytes[++i] - 128) << 12) +\n            ((bytes[++i] - 128) << 6) +\n            bytes[++i] -\n            128\n        : nPart > 247 && nPart < 252 && i + 4 < arrayLength /* five bytes */\n        ? ((nPart - 248) << 24) +\n          ((bytes[++i] - 128) << 18) +\n          ((bytes[++i] - 128) << 12) +\n          ((bytes[++i] - 128) << 6) +\n          bytes[++i] -\n          128\n        : nPart > 239 && nPart < 248 && i + 3 < arrayLength /* four bytes */\n        ? ((nPart - 240) << 18) +\n          ((bytes[++i] - 128) << 12) +\n          ((bytes[++i] - 128) << 6) +\n          bytes[++i] -\n          128\n        : nPart > 223 && nPart < 240 && i + 2 < arrayLength /* three bytes */\n        ? ((nPart - 224) << 12) + ((bytes[++i] - 128) << 6) + bytes[++i] - 128\n        : nPart > 191 && nPart < 224 && i + 1 < arrayLength /* two bytes */\n        ? ((nPart - 192) << 6) + bytes[++i] - 128 /* nPart < 127 ? */\n        : /* one byte */\n          nPart\n    );\n  }\n\n  return decoded;\n}\n","import { base64DecToArray, UTF8ArrToStr } from \"../helpers/base64\";\n\n/**\n * Try to decode a JWT. If the token is valid you'll get an object otherwise you'll get null\n * @param token - The JWT that you want to decode\n * @returns Decoded token\n */\nexport function decodeToken<T>(token: string): T | null;\nexport function decodeToken(token: string): Object | null;\nexport function decodeToken<T = Object>(token: string): T | null {\n  try {\n    // if the token has more or less than 3 parts or is not a string\n    // then is not a valid token\n    if (typeof token !== \"string\" || token.split(\".\").length !== 3) {\n      return null;\n    }\n\n    // payload ( index 1 ) has the data stored and\n    // data about the expiration time\n    const payload: string = token.split(\".\")[1];\n\n    const base64Bytes: number[] = base64DecToArray(payload);\n    // Convert utf-8 array to string\n    const jsonPayload: string = decodeURIComponent(UTF8ArrToStr(base64Bytes));\n    // Parse JSON\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error(\"There was an error decoding token: \", error);\n    // Return null if something goes wrong\n    return null;\n  }\n}\n\n/**\n * Verify if the token is expired or not\n * @param token - Your JWT\n * @returns boolean\n */\nexport function isTokenExpired(token: string): boolean {\n  const decodedToken: any = decodeToken(token);\n  let result: boolean = true;\n\n  if (decodedToken && decodedToken.exp) {\n    const expirationDate: Date = new Date(0);\n    expirationDate.setUTCSeconds(decodedToken.exp); // sets the expiration seconds\n    // compare the expiration time and the current time\n    result = expirationDate.valueOf() < new Date().valueOf();\n  }\n\n  return result;\n}\n","import { useState, useEffect } from \"react\";\nimport { decodeToken, isTokenExpired } from \"../jwt\";\n\n/**\n * This function will help you to decode a JWT and know if it's expired or not\n * @param userJwt - Your JWT\n * @returns An object containing the properties isExpired, decodedToken and reEvaluateToken\n */\nexport function useJwt<T>(userJwt: string): IUseJwt<T>;\nexport function useJwt(userJwt: string): IUseJwt;\nexport function useJwt<T>(userJwt: string): IUseJwt<T> {\n  const [isExpired, setIsExpired] = useState<boolean>(false);\n  const [decodedToken, setDecodedToken] = useState<T | null>(null);\n\n  useEffect(() => {\n    evaluateToken(userJwt);\n  }, [userJwt]);\n\n  const evaluateToken = (token: string) => {\n    setDecodedToken(decodeToken<T>(token));\n    setIsExpired(isTokenExpired(token));\n  };\n\n  return { isExpired, decodedToken, reEvaluateToken: evaluateToken };\n}\n\ninterface IUseJwt<T = Object> {\n  isExpired: boolean;\n  decodedToken: T | null;\n  reEvaluateToken: (token: string) => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}